**Временная сложность**: $O(n)$, где $n$ - длина наименьшей строки

**Пространственная сложность**: $O(1)$

Алгоритм:
- Для начала сведём задачу к случаю, когда $len(s) \leq len(t)$ (если $len(s) > len(t)$, рекурсивно вызываем исходную функцию, поменяв аргументы местами) 
- Заводим указатель $i$ и пробегаемся по строке $s$:
  - Если $s[i] = t[i]$, просто идём дальше
  - Если $s[i] \neq t[i]$:
    - Если строки одинаковы по длине, то просто проверяем, равны ли оставшиеся элементы строк
    - Если строки отличаются по длине, то проверяем, что $s[i:] = t[i+1:]$
- В конце надо проверить, что строка $t$ длиннее ровно на 1 символ, так как раз мы дошли до этого момента, то строка $t$ полностью содержит в себе строку $s$

**Почему этот код работает для случая, когда строки равны по длине и отличаются только последним символом?**

В go диапазоны для слайсов работают немного странно:

```go
package main

func main() {
    a := []int{1,2,3} //len(a) == 3
    fmt.Println(a[3:]) //выведется пустой массив
    fmt.Println(a[3]) //паника
    fmt.Println(a[4:]) //паника
}
```